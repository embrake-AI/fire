---
description: SolidJS reactive patterns and anti-patterns
globs: ['**/*.tsx']
alwaysApply: false
---

# SolidJS Patterns & Anti-Patterns

SolidJS is NOT React. It uses fine-grained reactivity where signals must be called to access values.

## Core Reactivity Rules

### Rule 1: Signals Are Functions

```tsx
const [count, setCount] = createSignal(0)

// ✅ Correct - call the signal
console.log(count())
;<div>{count()}</div>

// ❌ Wrong - this logs the getter function, not the value
console.log(count)
```

### Rule 2: Loader Data Returns Signals

```tsx
function MyRoute() {
    const data = Route.useLoaderData()

    // ✅ Correct - data() returns the actual value
    return <div>{data().title}</div>

    // ❌ Wrong - data is a signal, not the value
    return <div>{data.title}</div>
}
```

### Rule 3: Don't Destructure Reactive Props

```tsx
// ❌ WRONG - loses reactivity, values freeze at first render
function Badge({ label, count }) {
    return (
        <span>
            {label}: {count}
        </span>
    )
}

// ✅ CORRECT - maintains reactivity
function Badge(props) {
    return (
        <span>
            {props.label}: {props.count}
        </span>
    )
}

// ✅ ALSO CORRECT - use splitProps for separating concerns
function Badge(props) {
    const [local, others] = splitProps(props, ['label', 'count'])
    return (
        <span {...others}>
            {local.label}: {local.count}
        </span>
    )
}
```

### Rule 4: Use Control Flow Components

```tsx
import { Show, For, Switch, Match, Index } from "solid-js";

// ✅ Use Show for conditionals
<Show when={user()} fallback={<LoginButton />}>
  {(u) => <UserProfile user={u()} />}
</Show>

// ✅ Use For for lists (by reference)
<For each={items()}>
  {(item, index) => <Item item={item} index={index()} />}
</For>

// ✅ Use Index for lists (by index - better for primitives)
<Index each={counts()}>
  {(count, index) => <span>{index}: {count()}</span>}
</Index>

// ❌ Avoid ternary for conditional rendering
{condition ? <A /> : <B />}  // Creates/destroys on every change

// ❌ Avoid .map() for lists
{items().map(item => <Item item={item} />)}  // Re-renders entire list
```

## Effects & Memos

### createEffect - Side Effects

```tsx
createEffect(() => {
    // Runs when any signal inside changes
    console.log('Count is:', count())
    document.title = `Count: ${count()}`
})

// With on() for explicit dependencies
import { on } from 'solid-js'

createEffect(
    on(count, (value, prev) => {
        console.log('Count changed from', prev, 'to', value)
    })
)
```

### createMemo - Derived Values

```tsx
const doubled = createMemo(() => count() * 2)
const filtered = createMemo(() => items().filter((item) => item.active))

// Use in templates
;<div>{doubled()}</div>
```

### onMount / onCleanup

```tsx
import { onMount, onCleanup } from 'solid-js'

function Timer() {
    const [seconds, setSeconds] = createSignal(0)

    onMount(() => {
        const id = setInterval(() => setSeconds((s) => s + 1), 1000)
        onCleanup(() => clearInterval(id))
    })

    return <div>{seconds()} seconds</div>
}
```

## Resources (Async Data)

```tsx
import { createResource, Suspense } from 'solid-js'

function UserProfile(props) {
    const [user] = createResource(() => props.userId, fetchUser)

    return (
        <Suspense fallback={<Loading />}>
            <Show when={!user.error} fallback={<Error error={user.error} />}>
                <div>{user()?.name}</div>
            </Show>
        </Suspense>
    )
}
```

## Stores (Complex State)

```tsx
import { createStore, produce } from 'solid-js/store'

const [state, setState] = createStore({
    user: { name: 'John', age: 30 },
    items: [],
})

// Direct path update
setState('user', 'name', 'Jane')

// Produce for complex updates
setState(
    produce((s) => {
        s.items.push({ id: 1, name: 'New Item' })
    })
)

// Use in templates
;<div>{state.user.name}</div>
```

## Component Patterns

### Polymorphic Components

```tsx
import type { ValidComponent } from "solid-js";
import { splitProps } from "solid-js";
import { Dynamic } from "solid-js/web";

interface ButtonProps<T extends ValidComponent = "button"> {
  as?: T;
  variant?: "primary" | "secondary";
  class?: string;
}

function Button<T extends ValidComponent = "button">(props: ButtonProps<T>) {
  const [local, others] = splitProps(props, ["as", "variant", "class"]);

  return (
    <Dynamic
      component={local.as || "button"}
      class={cn(buttonStyles({ variant: local.variant }), local.class)}
      {...others}
    />
  );
}

// Usage
<Button>Click me</Button>
<Button as="a" href="/about">Link Button</Button>
```

### Children with Slots

```tsx
import { children, type JSX } from 'solid-js'

interface CardProps {
    children: JSX.Element
    header?: JSX.Element
    footer?: JSX.Element
}

function Card(props: CardProps) {
    const resolved = children(() => props.children)

    return (
        <div class="card">
            <Show when={props.header}>
                <div class="card-header">{props.header}</div>
            </Show>
            <div class="card-body">{resolved()}</div>
            <Show when={props.footer}>
                <div class="card-footer">{props.footer}</div>
            </Show>
        </div>
    )
}
```

### Context Pattern

```tsx
import { createContext, useContext, type ParentComponent } from 'solid-js'

interface ThemeContextValue {
    theme: () => 'light' | 'dark'
    toggle: () => void
}

const ThemeContext = createContext<ThemeContextValue>()

export const ThemeProvider: ParentComponent = (props) => {
    const [theme, setTheme] = createSignal<'light' | 'dark'>('light')

    const value: ThemeContextValue = {
        theme,
        toggle: () => setTheme((t) => (t === 'light' ? 'dark' : 'light')),
    }

    return <ThemeContext.Provider value={value}>{props.children}</ThemeContext.Provider>
}

export function useTheme() {
    const context = useContext(ThemeContext)
    if (!context) throw new Error('useTheme must be used within ThemeProvider')
    return context
}
```

## Event Handlers

```tsx
// Inline handlers
<button onClick={() => setCount(c => c + 1)}>Increment</button>

// With event parameter
<input onInput={(e) => setValue(e.currentTarget.value)} />

// Prevent default
<form onSubmit={(e) => {
  e.preventDefault();
  handleSubmit();
}}>

// Delegated events (on:event syntax for native events)
<div on:click={(e) => console.log("Native click", e)} />
```

## Ref Pattern

```tsx
let inputRef: HTMLInputElement | undefined;

onMount(() => {
  inputRef?.focus();
});

<input ref={inputRef} />

// Or with callback
<input ref={(el) => {
  // el is guaranteed to exist here
  el.focus();
}} />
```

## Common Mistakes to Avoid

### 1. Accessing Signals in Objects Without Calling

```tsx
// ❌ Wrong
const obj = { count: count } // Stores the getter, not value

// ✅ Correct
const obj = { count: count() } // Stores current value (snapshot)
// OR keep reactive
const getObj = () => ({ count: count() })
```

### 2. Spreading Reactive Props Incorrectly

```tsx
// ❌ Wrong - loses reactivity
const { class: className, ...rest } = props

// ✅ Correct
const [local, rest] = splitProps(props, ['class'])
```

### 3. Forgetting () When Reading Search/Params

```tsx
function Page() {
    const search = Route.useSearch()
    const params = Route.useParams()

    // ❌ Wrong
    console.log(search.page)

    // ✅ Correct - search and params ARE objects, but loader data is a signal
    // Actually, useSearch() returns an object directly (not a signal)
    console.log(search.page) // This IS correct for search

    // For loader data:
    const data = Route.useLoaderData()
    console.log(data().title) // data IS a signal
}
```

### 4. Using React Hooks Syntax

```tsx
// ❌ These don't exist in Solid
useState() // Use createSignal
useEffect() // Use createEffect
useMemo() // Use createMemo
useRef() // Use let ref or createSignal
useCallback() // Just use regular functions
```
