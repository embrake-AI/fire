---
description: Data loading with Suspense in dashboard routes
alwaysApply: false
---

# Static Shell + Suspense Pattern

Use this pattern for pages that fetch data: render static UI immediately while data-dependent content suspends.

## Structure

```tsx
// Route points directly to component (no Suspense wrapper)
export const Route = createFileRoute('/_authed/my-page')({
    component: MyPage,
})

// Static shell renders immediately
function MyPage() {
    return (
        <Card>
            <CardHeader>
                <CardTitle>Page Title</CardTitle> {/* Static - renders immediately */}
            </CardHeader>
            <Suspense fallback={<ContentSkeleton />}>
                <PageContent /> {/* Data-dependent - suspends */}
            </Suspense>
        </Card>
    )
}

// Data fetching happens in the content component
function PageContent() {
    const query = useQuery(() => ({
        queryKey: ['data'],
        queryFn: fetchData,
    }))

    return <CardContent>{/* Render query.data */}</CardContent>
}

// Skeleton matches content structure (not the full page)
function ContentSkeleton() {
    return (
        <CardContent>
            <Skeleton class="h-10 w-36" />
        </CardContent>
    )
}
```

## Key Principles

1. **Static shell renders immediately**: Headers, navigation, card containers, page layout
2. **Suspense wraps only data-dependent content**: The component that calls `useQuery`
3. **Skeleton matches content structure**: Don't duplicate static elements in skeleton

## Animation Guidelines

⚠️ **Do NOT use `animate-in fade-in` anywhere in data-fetching routes**

These animations cause flickering on every refetch, even when the DOM doesn't change. The animation class re-triggers whenever the component re-renders. This applies to:

-   Data content components
-   Skeleton/loading fallbacks (they re-render on refetch too!)
-   Any component inside a Suspense boundary

**Bad** - causes flicker:

```tsx
function PageContent() {
    const query = useQuery(...)
    return <div class="animate-in fade-in duration-200">{/* data */}</div>
}

function ContentSkeleton() {
    return <div class="animate-in fade-in duration-200">{/* skeleton */}</div>
}
```

**Good** - no animations:

```tsx
function PageContent() {
    const query = useQuery(...)
    return <div>{/* data */}</div>
}

function ContentSkeleton() {
    return <div>{/* skeleton */}</div>
}
```

**Where animations ARE appropriate:**

-   UI components (popovers, tooltips, selects - visibility changes via `fade-in-0`)
-   One-time app shell transitions (e.g., after auth is ready)

## When to Use Suspense vs Show

| Use Case                             | Tool         |
| ------------------------------------ | ------------ |
| Data fetching with tanstack query    | `<Suspense>` |
| Conditional rendering based on state | `<Show>`     |
| Toggle visibility based on signals   | `<Show>`     |

## Skeleton Component

Use the `Skeleton` component from `~/components/ui/skeleton`:

```tsx
import { Skeleton } from "~/components/ui/skeleton";

// Variants
<Skeleton class="h-10 w-36" />                    // rectangular (default)
<Skeleton variant="text" class="h-4 w-24" />      // text line
<Skeleton variant="circular" class="w-8 h-8" />   // avatar/icon
```

## Examples in Codebase

-   `_authed.config.integrations.tsx` - Card with static header, suspense on content
-   `_authed.config.entry-points.tsx` - Card shell with suspense on list
-   `_authed.index.tsx` - Page container with suspense on incident sections
-   `_authed.incidents.$incidentId.tsx` - Static back link, suspense on incident details
